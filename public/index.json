
[{"content":"\rScenario #\rNASA received a notification from their ISP that it appeared that some copyrighted files were transferred to and from the ISS (Guess astronauts need movies too). We weren\u0026rsquo;t able to recover all of the files, but we were able to capture some traffic from the final download before the user signed off. If you can help recover the file that was downloaded perhaps you can shed some light on what they were doing?\nSolution #\rFirst, I use this filter on wireshark:\nbittorrent BitTorrent transfers files in pieces (chunks). Each piece has:\nPiece Index: Identifies which piece of the file Begin Offset: Position within that piece Data: The actual file content\nWe need to identify and extract piece messages (message type 7).\ntshark -r evidence.pcapng -Y \u0026#34;bittorrent.msg.type == 7\u0026#34; -T fields -e bittorrent.piece.index -e bittorrent.piece.begin -e bittorrent.piece.length This shows we have pieces with indices from 0x00 to 0x14 (21 pieces total), with each piece divided into 16KB chunks (0x4000 bytes).\nInitially attempting to extract all piece data in order fails:\ntshark -r evidence.pcapng -Y \u0026#34;bittorrent.msg.type == 7\u0026#34; -T fields -e bittorrent.piece.data \u0026gt; piece_data.hex xxd -r -p piece_data.hex \u0026gt; extracted_file.pdf This produces a corrupted PDF because BitTorrent pieces arrive in random order, not sequentially.\nThe key insight is that BitTorrent pieces must be reassembled in the correct order:\nSort by piece index (0x00, 0x01, 0x02, etc.) Within each piece, sort by begin offset (0x0000, 0x4000, 0x8000, etc.)\nSolution #\r#!/usr/bin/env python3 import subprocess import binascii import sys def extract_pieces(): \u0026#34;\u0026#34;\u0026#34;Extract all BitTorrent pieces with their metadata\u0026#34;\u0026#34;\u0026#34; cmd = [ \u0026#39;tshark\u0026#39;, \u0026#39;-r\u0026#39;, \u0026#39;evidence.pcapng\u0026#39;, \u0026#39;-Y\u0026#39;, \u0026#39;bittorrent.msg.type == 7\u0026#39;, \u0026#39;-T\u0026#39;, \u0026#39;fields\u0026#39;, \u0026#39;-e\u0026#39;, \u0026#39;bittorrent.piece.index\u0026#39;, \u0026#39;-e\u0026#39;, \u0026#39;bittorrent.piece.begin\u0026#39;, \u0026#39;-e\u0026#39;, \u0026#39;bittorrent.piece.data\u0026#39; ] result = subprocess.run(cmd, capture_output=True, text=True) if result.returncode != 0: print(f\u0026#34;Error running tshark: {result.stderr}\u0026#34;) return {} pieces = {} for line in result.stdout.strip().split(\u0026#39;\\n\u0026#39;): if not line.strip(): continue parts = line.split(\u0026#39;\\t\u0026#39;) if len(parts) \u0026gt;= 3: piece_idx = int(parts[0], 16) begin_offset = int(parts[1], 16) piece_data = parts[2] if piece_idx not in pieces: pieces[piece_idx] = {} pieces[piece_idx][begin_offset] = piece_data return pieces def reassemble_file(pieces): \u0026#34;\u0026#34;\u0026#34;Reassemble pieces into complete file\u0026#34;\u0026#34;\u0026#34; complete_data = b\u0026#34;\u0026#34; # Sort pieces by index for piece_idx in sorted(pieces.keys()): print(f\u0026#34;Processing piece {piece_idx:02x}\u0026#34;) piece_data = b\u0026#34;\u0026#34; # Sort offsets within each piece for offset in sorted(pieces[piece_idx].keys()): hex_data = pieces[piece_idx][offset] if hex_data: # Skip empty data try: chunk = binascii.unhexlify(hex_data) piece_data += chunk print(f\u0026#34; Offset {offset:06x}: {len(chunk)} bytes\u0026#34;) except Exception as e: print(f\u0026#34; Error decoding offset {offset:06x}: {e}\u0026#34;) complete_data += piece_data return complete_data def main(): print(\u0026#34;Extracting BitTorrent pieces...\u0026#34;) pieces = extract_pieces() if not pieces: print(\u0026#34;No pieces found!\u0026#34;) return print(f\u0026#34;Found {len(pieces)} pieces\u0026#34;) for idx in sorted(pieces.keys()): print(f\u0026#34;Piece {idx:02x}: {len(pieces[idx])} chunks\u0026#34;) print(\u0026#34;\\nReassembling file...\u0026#34;) complete_data = reassemble_file(pieces) print(f\u0026#34;Total reassembled size: {len(complete_data)} bytes\u0026#34;) # Write to file with open(\u0026#39;reassembled_file.bin\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(complete_data) print(\u0026#34;Saved as reassembled_file.bin\u0026#34;) # Try to identify file type if complete_data.startswith(b\u0026#39;%PDF\u0026#39;): print(\u0026#34;File appears to be a PDF!\u0026#34;) with open(\u0026#39;reassembled_file.pdf\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(complete_data) print(\u0026#34;Also saved as reassembled_file.pdf\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() ~ Carbo\n","date":"28 September 2025","externalUrl":null,"permalink":"/posts/sunshine-ctf/","section":"Posts \u0026 Writeups","summary":"","title":" Intergalactic Copyright Infringement - SunshineCTF 2025","type":"posts"},{"content":"In this analysis, I will walk through the process of identifying and understanding the behavior of the Amadey Trojan Stealer by examining a Windows memory dump. The analysis will cover identifying the malicious processes, locating malware, and tracing its communication with external servers\nScenario #\rAn after-hours alert from the Endpoint Detection and Response (EDR) system flags suspicious activity on a Windows workstation. The flagged malware aligns with the Amadey Trojan Stealer. Your job is to analyze the presented memory dump and create a detailed report for actions taken by the malware.\nSolution #\rIn the memory dump analysis, determining the root of the malicious activity is essential for comprehending the extent of the intrusion. What is the name of the parent process that triggered this malicious behavior? First, I used windows.pslist and windows.pstree to list all processes and to visualize the parent-child process relationships:\nvol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.pslist # all processes vol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.pstree # parent child processes relations I found lssass.exe to be associated with the suspicious parent process rundll32.exe, indicating this as the root of the malicious behavior..\nlssass.exe\n2.Once the rogue process is identified, its exact location on the device can reveal more about its nature and source. Where is this process housed on the workstation?\nNext, I used windows.filescan to find the location of the malware:\n/vol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.filescan | grep \u0026#34;lssass.exe\u0026#34; C:\\Users\\0XSH3R~1\\AppData\\Local\\Temp\\925e7e99c5\\lssass.exe\nPersistent external communications suggest the malware’s attempts to reach out C2C server. Can you identify the Command and Control (C2C) server IP that the process interacts with? So, i used windows.netscan\nvol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.netscan | grep \u0026#34;lssass.exe\u0026#34; 41.75.84.12\nFollowing the malware link with the C2C, the malware is likely fetching additional tools or modules. How many distinct files is it trying to bring onto the compromised workstation? I tried to dump malicious Process:\nvol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.memmap.Memmap --pid 2748 --dump So after dumping the process i used strings command to extract HTTP GET Requests:\nstrings pid.2748.dmp | grep -A 5 -i \u0026#34;^get /\u0026#34; The answer is: 2\nIdentifying the storage points of these additional components is critical for containment and cleanup. What is the full path of the file downloaded and used by the malware in its malicious activity? From Q4 we known that the attacker downloaded another 2 malicious files named :\ncred64.dll clip64.dll I used windows.filescan to find the location of the second malware:\n/vol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.filescan | grep \u0026#34;clip64.dll\u0026#34; c:\\Users\\0xSh3rl0ck\\AppData\\Roaming\\116711e5a2ab05\\clip64.dll\nOnce retrieved, the malware aims to activate its additional components. Which child process is initiated by the malware to execute these files? From question n°5:\nRUNDLL32.EXE\n7.Understanding the full range of Amadey’s persistence mechanisms can help in an effective mitigation. Apart from the locations already spotlighted, where else might the malware be ensuring its consistent presence?\nvol.py -f ../../Artifacts/Windows\\ 7\\ x64-Snapshot4.vmem windows.filescan | grep \u0026#34;lssass.exe\u0026#34; c:\\Windows\\System32\\Tasks\\lssass.exe\n~ Carbo\n","date":"7 September 2025","externalUrl":null,"permalink":"/posts/amadayelab-cyberdefenders/","section":"Posts \u0026 Writeups","summary":"","title":"Amadey Lab - Cyberdefenders","type":"posts"},{"content":"\rScenario #\rIn 2025, a new bakery chain called VeryCheap has taken Denmark by storm, selling their brunsviger at suspiciously low prices and driving independent bakeries out of business. But behind the sugary facade, something doesn\u0026rsquo;t add up. They must be losing money with such low prices - and why are so many of their customers in suits?\nA recent police raid seized one of their office PCs. Your task: perform a full forensic analysis of the disk and find what VeryCheap is really hiding!\nSolution #\rIn this challenge we have a disk image, and as the description hints, our task was to analyze it thoroughly and uncover what VeryCheap was really hiding.\nI used Autopsy to open the disk file.\nStored Files #\rI found this information:\nDocuments: A few brunner recipes and a test.hc file - the default extension for VeraCrypt containers Downloads: Installers for 7-Zip, Google Chrome, and LibreOffice Pictures: A few downloaded brunsviger images from the internet with Zone.Identifier files (Mark Of The Web). Also a seemingly generated image of a VeryCheap bakery, VeryCheapBrunner.png. In addition, there are deleted files. The recycle bin has a few files that also point to the original locations. With most forensic tools, the files and their content can also be seen when navigating to their original location, just marked deleted:\nC:\\Users\\Joe\\Downloads\\VeraCrypt Setup 1.26.24.exe C:\\Users\\Joe\\Desktop\\test_container_password.txt Password for my test container is \u0026#34;brunsviger\u0026#34;. ------------------------------METADATA------------------------------ Explanation #\rThe next step was to download VeraCrypt and attempt to open the previously discovered container file, test.hc, using the recovered password. With \u0026ldquo;brunsviger\u0026rdquo; as the password, I successfully mounted the volume and accessed its contents. Inside, I found a text file, which, unfortunately, turned out to be a decoy rather than the actual secret.\nNot discouraged, I continued investigating and recalled that VeraCrypt can also be used via the command line. This prompted me to examine the PowerShell history for any potentially useful commands.\nI checked the following path: C:\\Users\\Joe\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt\nAfter extracting the necessary files from the disk, I returned to VeraCrypt and used the recovered password and keyfile to mount the hidden container. Inside, I found four files, but the one that stood out — and ultimately proved useful — was VeryCheapVerySecretRecipe.txt.\nFrom the text file, we obtained two key hints. The first — “that’s why I keep so many sticky notes around” — pointed us toward examining Sticky Notes artifacts on the disk. The second — “some castles might have a back entrance with a different key” — hinted that the same VeraCrypt container could potentially be unlocked again using a different password stored elsewhere.\nFollowing this lead, I navigated to the Sticky Notes storage location at: C:\\Users\\Joe\\AppData\\Local\\Packages\\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\\LocalState\\plum.sqlite.\nWhen I opened the file, I found another useful hint hidden within the notes that could lead to more information about the encrypted container.\nOne line stood out: “Never save anything sensitive as a file on disk, just keep it in an unsaved Notepad window.” This pointed us directly toward investigating Notepad’s unsaved or recovery data, as Notepad automatically stores unsaved content for recovery when reopened.\nFollowing this clue, I navigated to the Notepad recovery data location: C:\\Users\\Joe\\AppData\\Local\\Packages\\Microsoft.WindowsNotepad_8wekyb3d8bbwe.\nWhile examining the Notepad artifact, I came across a clue referencing VeraCrypt’s Hidden Volume feature. For context, a hidden volume is essentially a secret container embedded within a standard VeraCrypt volume. Both share the same file, but entering one password unlocks the decoy outer volume, while a different password reveals the hidden inner volume. This design supports plausible deniability — allowing a user to disclose the outer password without exposing the existence of the hidden data.\nAt the end of the Notepad file, I found the line: WhaaaatItCanHaveAnExtraHiddenVolume?!?\nThis was clearly intended as the password for the hidden volume.\nWith this new password, I was able to unlock the hidden container. Inside, I found an Excel file — and that’s where the real flag was stored.\n","date":"24 August 2025","externalUrl":null,"permalink":"/posts/brunner-ctf/","section":"Posts \u0026 Writeups","summary":"","title":"Very Cheap - BrunnerCTF 2025","type":"posts"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/","section":"Carbo's Blog","summary":"","title":"Carbo's Blog","type":"page"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":" ","date":"28 September 2025","externalUrl":null,"permalink":"/posts/","section":"Posts \u0026 Writeups","summary":"","title":"Posts \u0026 Writeups","type":"posts"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/protocol-bittorrent/","section":"Tags","summary":"","title":"Protocol-Bittorrent","type":"tags"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/sunshine2025/","section":"Tags","summary":"","title":"Sunshine2025","type":"tags"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"28 September 2025","externalUrl":null,"permalink":"/tags/wireshark/","section":"Tags","summary":"","title":"Wireshark","type":"tags"},{"content":"","date":"7 September 2025","externalUrl":null,"permalink":"/tags/cyberdefenders/","section":"Tags","summary":"","title":"Cyberdefenders","type":"tags"},{"content":"","date":"7 September 2025","externalUrl":null,"permalink":"/tags/memory-dump/","section":"Tags","summary":"","title":"Memory-Dump","type":"tags"},{"content":"","date":"7 September 2025","externalUrl":null,"permalink":"/tags/volatility3/","section":"Tags","summary":"","title":"Volatility3","type":"tags"},{"content":"","date":"24 August 2025","externalUrl":null,"permalink":"/tags/autopsy/","section":"Tags","summary":"","title":"Autopsy","type":"tags"},{"content":"","date":"24 August 2025","externalUrl":null,"permalink":"/tags/brunnerctf/","section":"Tags","summary":"","title":"Brunnerctf","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]